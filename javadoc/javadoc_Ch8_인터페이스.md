# 👤 CH 08 인터페이스
## 인터페이스의 역할 
자바에서 인터페이스는 객체의 사용 방법을 정의한 타입이다. 인터페이스는 객체의 교환성을 높여주기 때문에 다형성을 구현하는 매우 중요한 역할을 한다. 특히 자바 8에서 인터페이스의 중요성은 더욱 커졌다. 람다식은 함수적 인터페이스의 구현 객체를 생성하기 떄문이다.인터페이스는 개발 코드와 객체가 서로 통신하는 접점 역할을 한다. 개발 코드가 인터페이스의 메소드를 호출하면 인터페이스는 객체의 메소드를 호출시킨다. 그렇기 때문에 개발 코드는 객체의 내부 구조를 알 필요가 없고 인터페이스의 메소드만 알고 있으면 된다.

__인터페이스가 개발 코드에서 메소드 호출하면 대신 객체의에 메소드를 호출하고 리턴값을 객체로부터 받으면 개발 코드로 리턴해준다.__

#### 그럼 개발 코드가 직접 객체의 메소드를 호출하면 간단한데, 왜 중간에 인타페이스를 두는것인가?
-> 개발 코드를 수정하지 않고 사용하는 객체를 변경할 수 있도록 하기 위해서이다. 따라서 실행 내용과 리턴값이 다를 수 있다. 개발 코드 측면에서는 코드 변경 없이 실행 내용과 리턴값을 다양화할 수 있다는 장점을 가진다.

___물리적인 형태는 클래스와 동일, 선언 방식이 다르다.___

### 인터페이스 선언 
인터페이스 선언은 클래스 키워드 대힌에 interface 키워드를 사용한다.
```java
public interface 인터페이스명{ ... }
```

클래스
- 필드
- 생성자
- 메소드

인터페이스
- 상수
- 메소드

인터페이스는 객체로 생성할 수 없기 때문에 생성자를 가질 수 ㅇ벗다.
```java
interface nameOfTheInterface{
	//상수
	타입 상수명;
	//추상 메소드
	타입 메소드명();
	//디폴트 메소드
	default 타입 메소드명(매개변수, ...){...}
	//정적 메소드
	static 타입 메소드명(매개변수){...}

}
```

- 상수 필드
인터페이스는 객체 (사용설명서)이므로 런타임 시 데이터를 저장할 수 있는 필드를 선언할 수 ㅇ벗다. 그러나 상수 필드는 선언이 가능하다. 상수는 인터페이스에 고정된 값으로 런타임 시에 데이터를 바꿀 수 없다. 상수 초기값 대입해야한다.

- 추상 메소드
추상 메소드는 객체가 가지고 있는 메소드를 설명한 것으로 호출할 때 어떤 매개값이 필요하고, 리턴 타입이 무엇인지만 알려준다. 실제 실행부는 객체가 가지고 있다.

- 디폴트 메소드
객체가 가지고 있는 인스턴스 메소드이다. 

- 정적 메소드
객체가 없어도 인터페이스만으로 호출이 가능한다.

#### 인터페이스 사용
인터페이스로 구현 객체를 사용하려면 다음과 같이 인터페이스 변수를 선언하고 구현 객체를 대입해야한다. 인터페이스 변수는 참조 타입이기 때문에 구현 객체가 대입될 경우 구현 개게의 번지를 저장한다.

```java
인터페이스 interVariable;
interVariable = new 객체명();
```

#### 추상메소드 사용
```java
인터페이스 interVariable = new 객체명();
interVariable.추상메소드1();
interVariable.추상메소드2();
```

#### 디폴트 메소드 사용
```java
인터페이스명.디폴트메소드(); //불가능
인터페이스 interVariable = new 객체명();
interVariable.디플트메소드();
```

디폴트 메소드는 인터페이스에 선언되지만, 인터페이스에서 바로 사용할 수 없다. 디폴트 메소드는 추상 메소드가 아닌 인스턴스 메소드이므로 구현 객체가 있어야 사용할 수 있다.
디폴트 메소드는 인터페이스의 모든 구현 객체가 가지고 있는 기본 메소드라고 생각하면된다. 그러나 어떤 구현 객체는 디폴트 메소드의 내용이 맞지 않아 수정이 필요할 수도 있다.

#### 정적 메소드 사용
인터페이스의 정적 메소드는 인터페이스로 바로 호출이 가능하다.

### 타입변환과 다형성
상속보다 인터페이스를 통해서 다형성을 구현하는 경우가 더 많다. 다형성은 하나의 타입에 대입되는 객체에 따라서 실행 결과가 다양한 형태로 나오는 성질을 말한다. 부모 타입에 어떤 자식 객체를 대입하느냐에 따라 실행 결과가 달라지듯이, 인터페이스 타입에 어떤 구현 객체를 대입하느냐에 따라 실행 결과가 달라진다. 상속은 같은 종류의 하위 클래스를 만드는 기술이고, 인터페이스는 사용 방법이 동일한 클래스를 만드는 기술이라는 개념적 차이점은 있지만 둘 다 다형성을 구현하는 기술임에는 틀림없다.

#### 자동 타입 변환
구현 객체가 인터페이스 타입으로 변환되는 것은 자동 타입 변환에 해당된다. 인터페이스 구현 클래스를 상속해서 자식 클래스를 만들었다면 자식 객체 역시 인터페이스 타입으로 자동 타입 변환시킬 수 있다.

#### 필드의 다형성
상속에서는 타이어 클래스 타입에 한국 타이어와 금호 타이어라는 자식 객체를 대입해서 교체할 수 있음을 보여주었지만, 아래 그림은 타이어가 클래스 타입이 아니고 인터페이스라는 점과 한국 타이어와 금호 타이어는 자식 클래스가 아니라 구현 클래스라는 점이다.
한국 타이어와 금호 타이어는 공통적으로 타이어 인터페이스를 구현했기 때문에 모두 타이어 인터페이스에 있는 메소드를 가지고 있다. 따라서 타이어 인터페이스로 동일하게 사용할 수 있는 교체 가능한 객체에 해당한다.

### 인터페이스 상속
인터페이스도 다른 인터페이스를 상속할 수 있다. 이터페이스는 클래스아는 달리 다중 상속을 허용한다. 다음과 같이 extends 키워드 뒤에 상속할 틴터페이스들을 나열할 수 있다.
하위 인터페이스를 구현하는 클래스는 하위 인터페이스의 메소드분만 아니라 상위 인터페이스의 모든 추상 메소드에 대한 실체 메소드를 가지고 있어야 한다. 구현 클래스로부터 객체를 생성하고 나서 다음과 같이 하위 및 상위 인터페이스 타입으로 변환이 가능하다.
```java
하위인터페이스 변수 = new 구현클래스(...);
상위인터페이스1 변수 = new 구현클래스(...);
상위인터페이스2 변수 = new 구현클래스(...);
```

하위 인터페이스로 타입 변환이 되면 상하위 인터페이스의 메소드 뿐만 아니라 상위 인터페이스의 모든 추상메소드에 대한 실체 메소드를 가지고 있어야한다.

### 디폴트 메소드와 인터페이스 확장
디폴트 메소드는 인터페이스에 선언된 인스턴스 메소드이기 때문에 구현 객체가 있어야 사용할 수 있다. 선언은 인터페이스에서 하고, 사용은 구현 객체가 있어야 사용할 수 있다. 디폴트 메소드는 모든 구현 객체에서 공유하는 기본 메소드처럼 보이지만, 사실은 인터페이스에서 디폴트 메소드를 허용한 다른 이유가 있다.

#### 디폴트 메소드의 필요성
기존 인터페이스를 확장해서 새로운 기능을 추가하기 위해서이다. 기존 인터페이스의 이름과 추상 메소드의 변경 없이 디폴트 메소드만 추가할 수 있기 때문에 이전에 개발한 구현 클래스를 그대로 사용할 수 있음녀서 새롭게 개발하는 클래스는 디폴트 메소드를 활용할 수 있다.

